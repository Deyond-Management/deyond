/**
 * DeyondCrypt - X3DH Key Exchange
 *
 * Extended Triple Diffie-Hellman (X3DH) key agreement protocol.
 * Used to establish an initial shared secret between two parties
 * for starting a Double Ratchet session.
 *
 * Adapted from Signal Protocol for blockchain wallets:
 * - Identity Key derived from wallet private key
 * - Pre-keys for asynchronous messaging
 * - Multi-chain support
 *
 * Reference: https://signal.org/docs/specifications/x3dh/
 */

import {
  ChainType,
  KeyPair,
  IdentityKeyPair,
  SignedPreKey,
  OneTimePreKey,
  PreKeyBundle,
  DeyondCryptError,
  DeyondCryptErrorCode,
} from '../types';
import { ICryptoPrimitive, IKeyDerivation } from '../primitives';
import { keyDerivation } from '../primitives/SymmetricCrypto';

// =============================================================================
// Constants
// =============================================================================

const X3DH_INFO = new TextEncoder().encode('DeyondCrypt-X3DH');
const SIGNED_PREKEY_CONTEXT = new TextEncoder().encode('DeyondCrypt-SignedPreKey');

// =============================================================================
// Types
// =============================================================================

/**
 * Keys generated by Alice for initial message to Bob
 */
export interface X3DHInitiatorKeys {
  identityKey: KeyPair;
  ephemeralKey: KeyPair;
}

/**
 * Result of X3DH key agreement
 */
export interface X3DHResult {
  sharedSecret: Uint8Array;
  associatedData: Uint8Array;
}

/**
 * Initial message sent by Alice to Bob
 */
export interface X3DHInitialMessage {
  identityKey: Uint8Array;
  ephemeralKey: Uint8Array;
  usedOneTimePreKeyId?: number;
}

// =============================================================================
// X3DH Implementation
// =============================================================================

/**
 * X3DH Key Exchange Protocol
 * Establishes shared secret for Double Ratchet session
 */
export class X3DH {
  private cryptoPrimitive: ICryptoPrimitive;
  private kdf: IKeyDerivation;

  constructor(cryptoPrimitive: ICryptoPrimitive, kdf: IKeyDerivation = keyDerivation) {
    this.cryptoPrimitive = cryptoPrimitive;
    this.kdf = kdf;
  }

  // ---------------------------------------------------------------------------
  // Key Generation
  // ---------------------------------------------------------------------------

  /**
   * Generate identity key pair from wallet private key
   */
  async generateIdentityKeyPair(
    walletPrivateKey: Uint8Array,
    chainId: number | string,
    chainType: ChainType
  ): Promise<IdentityKeyPair> {
    const keyPair = await this.cryptoPrimitive.deriveMessagingKeyPair(walletPrivateKey, chainId);

    const address = this.cryptoPrimitive.publicKeyToAddress(keyPair.publicKey);

    return {
      ...keyPair,
      chainType,
      address,
    };
  }

  /**
   * Generate a signed pre-key
   */
  async generateSignedPreKey(identityKeyPair: KeyPair, keyId: number): Promise<SignedPreKey> {
    // Generate new key pair
    const keyPair = await this.cryptoPrimitive.generateKeyPair();

    // Create signature over the public key with context
    const signatureData = new Uint8Array(SIGNED_PREKEY_CONTEXT.length + keyPair.publicKey.length);
    signatureData.set(SIGNED_PREKEY_CONTEXT);
    signatureData.set(keyPair.publicKey, SIGNED_PREKEY_CONTEXT.length);

    const signature = await this.cryptoPrimitive.sign(signatureData, identityKeyPair.privateKey);

    return {
      keyId,
      keyPair,
      signature,
      timestamp: Date.now(),
    };
  }

  /**
   * Generate one-time pre-keys
   */
  async generateOneTimePreKeys(startKeyId: number, count: number): Promise<OneTimePreKey[]> {
    const preKeys: OneTimePreKey[] = [];

    for (let i = 0; i < count; i++) {
      const keyPair = await this.cryptoPrimitive.generateKeyPair();
      preKeys.push({
        keyId: startKeyId + i,
        keyPair,
      });
    }

    return preKeys;
  }

  /**
   * Create a pre-key bundle for publication
   */
  createPreKeyBundle(
    identityKeyPair: IdentityKeyPair,
    signedPreKey: SignedPreKey,
    oneTimePreKey?: OneTimePreKey
  ): PreKeyBundle {
    return {
      identityKey: identityKeyPair.publicKey,
      signedPreKey: {
        keyId: signedPreKey.keyId,
        publicKey: signedPreKey.keyPair.publicKey,
        signature: signedPreKey.signature,
      },
      oneTimePreKey: oneTimePreKey
        ? {
            keyId: oneTimePreKey.keyId,
            publicKey: oneTimePreKey.keyPair.publicKey,
          }
        : undefined,
      address: identityKeyPair.address,
      chainType: identityKeyPair.chainType,
    };
  }

  // ---------------------------------------------------------------------------
  // Key Exchange - Initiator (Alice)
  // ---------------------------------------------------------------------------

  /**
   * Perform X3DH as initiator (Alice)
   * Call this when starting a conversation with someone
   *
   * @param ourIdentityKey - Our identity key pair
   * @param theirPreKeyBundle - Their published pre-key bundle
   * @returns Shared secret and initial message to send
   */
  async initiateKeyExchange(
    ourIdentityKey: KeyPair,
    theirPreKeyBundle: PreKeyBundle
  ): Promise<{
    result: X3DHResult;
    initialMessage: X3DHInitialMessage;
  }> {
    // Verify signed pre-key signature
    const isValid = await this.verifySignedPreKey(theirPreKeyBundle);
    if (!isValid) {
      throw new DeyondCryptError(
        'Invalid signed pre-key signature',
        DeyondCryptErrorCode.INVALID_PREKEY_BUNDLE
      );
    }

    // Generate ephemeral key pair
    const ephemeralKey = await this.cryptoPrimitive.generateKeyPair();

    // Perform DH operations
    // DH1 = DH(IK_A, SPK_B)
    const dh1 = await this.cryptoPrimitive.computeSharedSecret(
      ourIdentityKey.privateKey,
      theirPreKeyBundle.signedPreKey.publicKey
    );

    // DH2 = DH(EK_A, IK_B)
    const dh2 = await this.cryptoPrimitive.computeSharedSecret(
      ephemeralKey.privateKey,
      theirPreKeyBundle.identityKey
    );

    // DH3 = DH(EK_A, SPK_B)
    const dh3 = await this.cryptoPrimitive.computeSharedSecret(
      ephemeralKey.privateKey,
      theirPreKeyBundle.signedPreKey.publicKey
    );

    // DH4 = DH(EK_A, OPK_B) if one-time pre-key is available
    let dh4: Uint8Array | null = null;
    if (theirPreKeyBundle.oneTimePreKey) {
      dh4 = await this.cryptoPrimitive.computeSharedSecret(
        ephemeralKey.privateKey,
        theirPreKeyBundle.oneTimePreKey.publicKey
      );
    }

    // Derive shared secret
    const sharedSecret = await this.deriveSharedSecret(dh1, dh2, dh3, dh4);

    // Create associated data (for AEAD binding)
    const associatedData = this.createAssociatedData(
      ourIdentityKey.publicKey,
      theirPreKeyBundle.identityKey
    );

    // Create initial message
    const initialMessage: X3DHInitialMessage = {
      identityKey: ourIdentityKey.publicKey,
      ephemeralKey: ephemeralKey.publicKey,
      usedOneTimePreKeyId: theirPreKeyBundle.oneTimePreKey?.keyId,
    };

    return {
      result: { sharedSecret, associatedData },
      initialMessage,
    };
  }

  // ---------------------------------------------------------------------------
  // Key Exchange - Responder (Bob)
  // ---------------------------------------------------------------------------

  /**
   * Complete X3DH as responder (Bob)
   * Call this when receiving the first message from someone
   *
   * @param ourIdentityKey - Our identity key pair
   * @param ourSignedPreKey - Our signed pre-key pair
   * @param ourOneTimePreKey - Our one-time pre-key pair (if used)
   * @param initialMessage - The initial message from Alice
   * @returns Shared secret
   */
  async completeKeyExchange(
    ourIdentityKey: KeyPair,
    ourSignedPreKey: KeyPair,
    ourOneTimePreKey: KeyPair | null,
    initialMessage: X3DHInitialMessage
  ): Promise<X3DHResult> {
    // Perform DH operations (mirror of Alice's operations)
    // DH1 = DH(SPK_B, IK_A)
    const dh1 = await this.cryptoPrimitive.computeSharedSecret(
      ourSignedPreKey.privateKey,
      initialMessage.identityKey
    );

    // DH2 = DH(IK_B, EK_A)
    const dh2 = await this.cryptoPrimitive.computeSharedSecret(
      ourIdentityKey.privateKey,
      initialMessage.ephemeralKey
    );

    // DH3 = DH(SPK_B, EK_A)
    const dh3 = await this.cryptoPrimitive.computeSharedSecret(
      ourSignedPreKey.privateKey,
      initialMessage.ephemeralKey
    );

    // DH4 = DH(OPK_B, EK_A) if one-time pre-key was used
    let dh4: Uint8Array | null = null;
    if (ourOneTimePreKey && initialMessage.usedOneTimePreKeyId !== undefined) {
      dh4 = await this.cryptoPrimitive.computeSharedSecret(
        ourOneTimePreKey.privateKey,
        initialMessage.ephemeralKey
      );
    }

    // Derive shared secret
    const sharedSecret = await this.deriveSharedSecret(dh1, dh2, dh3, dh4);

    // Create associated data (for AEAD binding)
    const associatedData = this.createAssociatedData(
      initialMessage.identityKey,
      ourIdentityKey.publicKey
    );

    return { sharedSecret, associatedData };
  }

  // ---------------------------------------------------------------------------
  // Helpers
  // ---------------------------------------------------------------------------

  /**
   * Verify a signed pre-key signature
   */
  async verifySignedPreKey(bundle: PreKeyBundle): Promise<boolean> {
    const signatureData = new Uint8Array(
      SIGNED_PREKEY_CONTEXT.length + bundle.signedPreKey.publicKey.length
    );
    signatureData.set(SIGNED_PREKEY_CONTEXT);
    signatureData.set(bundle.signedPreKey.publicKey, SIGNED_PREKEY_CONTEXT.length);

    return this.cryptoPrimitive.verify(
      signatureData,
      bundle.signedPreKey.signature,
      bundle.identityKey
    );
  }

  /**
   * Derive shared secret from DH outputs
   */
  private async deriveSharedSecret(
    dh1: Uint8Array,
    dh2: Uint8Array,
    dh3: Uint8Array,
    dh4: Uint8Array | null
  ): Promise<Uint8Array> {
    // Concatenate all DH outputs
    const totalLength = dh1.length + dh2.length + dh3.length + (dh4?.length ?? 0);
    const dhConcat = new Uint8Array(totalLength);

    let offset = 0;
    dhConcat.set(dh1, offset);
    offset += dh1.length;
    dhConcat.set(dh2, offset);
    offset += dh2.length;
    dhConcat.set(dh3, offset);
    offset += dh3.length;
    if (dh4) {
      dhConcat.set(dh4, offset);
    }

    // Derive 32-byte shared secret using HKDF
    return this.kdf.hkdf(dhConcat, null, X3DH_INFO, 32);
  }

  /**
   * Create associated data for AEAD
   * AD = Encode(IK_A) || Encode(IK_B)
   */
  private createAssociatedData(
    initiatorIdentityKey: Uint8Array,
    responderIdentityKey: Uint8Array
  ): Uint8Array {
    const ad = new Uint8Array(initiatorIdentityKey.length + responderIdentityKey.length);
    ad.set(initiatorIdentityKey);
    ad.set(responderIdentityKey, initiatorIdentityKey.length);
    return ad;
  }
}

// =============================================================================
// Pre-Key Store Interface
// =============================================================================

/**
 * Interface for storing pre-keys
 * Implementations can use secure storage, blockchain, or P2P distribution
 */
export interface IPreKeyStore {
  /**
   * Store a signed pre-key
   */
  storeSignedPreKey(signedPreKey: SignedPreKey): Promise<void>;

  /**
   * Get the current signed pre-key
   */
  getSignedPreKey(): Promise<SignedPreKey | null>;

  /**
   * Store one-time pre-keys
   */
  storeOneTimePreKeys(preKeys: OneTimePreKey[]): Promise<void>;

  /**
   * Get and remove a one-time pre-key by ID
   */
  consumeOneTimePreKey(keyId: number): Promise<OneTimePreKey | null>;

  /**
   * Get the count of remaining one-time pre-keys
   */
  getOneTimePreKeyCount(): Promise<number>;

  /**
   * Store identity key pair
   */
  storeIdentityKeyPair(identityKey: IdentityKeyPair): Promise<void>;

  /**
   * Get identity key pair
   */
  getIdentityKeyPair(): Promise<IdentityKeyPair | null>;
}

/**
 * In-memory implementation of PreKeyStore (for testing)
 */
export class InMemoryPreKeyStore implements IPreKeyStore {
  private identityKeyPair: IdentityKeyPair | null = null;
  private signedPreKey: SignedPreKey | null = null;
  private oneTimePreKeys: Map<number, OneTimePreKey> = new Map();

  async storeIdentityKeyPair(identityKey: IdentityKeyPair): Promise<void> {
    this.identityKeyPair = identityKey;
  }

  async getIdentityKeyPair(): Promise<IdentityKeyPair | null> {
    return this.identityKeyPair;
  }

  async storeSignedPreKey(signedPreKey: SignedPreKey): Promise<void> {
    this.signedPreKey = signedPreKey;
  }

  async getSignedPreKey(): Promise<SignedPreKey | null> {
    return this.signedPreKey;
  }

  async storeOneTimePreKeys(preKeys: OneTimePreKey[]): Promise<void> {
    for (const preKey of preKeys) {
      this.oneTimePreKeys.set(preKey.keyId, preKey);
    }
  }

  async consumeOneTimePreKey(keyId: number): Promise<OneTimePreKey | null> {
    const preKey = this.oneTimePreKeys.get(keyId);
    if (preKey) {
      this.oneTimePreKeys.delete(keyId);
      return preKey;
    }
    return null;
  }

  async getOneTimePreKeyCount(): Promise<number> {
    return this.oneTimePreKeys.size;
  }

  /**
   * Get next available one-time pre-key (for testing)
   */
  getNextOneTimePreKey(): OneTimePreKey | null {
    const firstKey = this.oneTimePreKeys.keys().next().value;
    if (firstKey !== undefined) {
      return this.oneTimePreKeys.get(firstKey) || null;
    }
    return null;
  }
}
